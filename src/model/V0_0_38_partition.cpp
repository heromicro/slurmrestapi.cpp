/**
 * Slurm Rest API
 * API to access and control Slurm.
 *
 * The version of the OpenAPI document: 0.0.38
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.6.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "slurmrestapi/model/V0_0_38_partition.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {



V0_0_38_partition::V0_0_38_partition()
{
    m_FlagsIsSet = false;
    m_Preemption_modeIsSet = false;
    m_Allowed_allocation_nodes = utility::conversions::to_string_t("");
    m_Allowed_allocation_nodesIsSet = false;
    m_Allowed_accounts = utility::conversions::to_string_t("");
    m_Allowed_accountsIsSet = false;
    m_Allowed_groups = utility::conversions::to_string_t("");
    m_Allowed_groupsIsSet = false;
    m_Allowed_qos = utility::conversions::to_string_t("");
    m_Allowed_qosIsSet = false;
    m_Alternative = utility::conversions::to_string_t("");
    m_AlternativeIsSet = false;
    m_Billing_weights = utility::conversions::to_string_t("");
    m_Billing_weightsIsSet = false;
    m_Default_memory_per_cpu = 0L;
    m_Default_memory_per_cpuIsSet = false;
    m_Default_time_limit = 0L;
    m_Default_time_limitIsSet = false;
    m_Denied_accounts = utility::conversions::to_string_t("");
    m_Denied_accountsIsSet = false;
    m_Denied_qos = utility::conversions::to_string_t("");
    m_Denied_qosIsSet = false;
    m_Preemption_grace_time = 0L;
    m_Preemption_grace_timeIsSet = false;
    m_Maximum_cpus_per_node = 0;
    m_Maximum_cpus_per_nodeIsSet = false;
    m_Maximum_memory_per_node = 0L;
    m_Maximum_memory_per_nodeIsSet = false;
    m_Maximum_nodes_per_job = 0;
    m_Maximum_nodes_per_jobIsSet = false;
    m_Max_time_limit = 0L;
    m_Max_time_limitIsSet = false;
    m_Min_nodes_per_job = 0;
    m_Min_nodes_per_jobIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_Nodes = utility::conversions::to_string_t("");
    m_NodesIsSet = false;
    m_Over_time_limit = 0;
    m_Over_time_limitIsSet = false;
    m_Priority_job_factor = 0;
    m_Priority_job_factorIsSet = false;
    m_Priority_tier = 0;
    m_Priority_tierIsSet = false;
    m_Qos = utility::conversions::to_string_t("");
    m_QosIsSet = false;
    m_State = utility::conversions::to_string_t("");
    m_StateIsSet = false;
    m_Total_cpus = 0;
    m_Total_cpusIsSet = false;
    m_Total_nodes = 0;
    m_Total_nodesIsSet = false;
    m_Tres = utility::conversions::to_string_t("");
    m_TresIsSet = false;
    m_Maximum_memory_per_cpu = 0L;
    m_Maximum_memory_per_cpuIsSet = false;
    m_Default_memory_per_node = 0L;
    m_Default_memory_per_nodeIsSet = false;
}

V0_0_38_partition::~V0_0_38_partition()
{
}

void V0_0_38_partition::validate()
{
    // TODO: implement validation
}

web::json::value V0_0_38_partition::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_FlagsIsSet)
    {
        val[utility::conversions::to_string_t(U("flags"))] = ModelBase::toJson(m_Flags);
    }
    if(m_Preemption_modeIsSet)
    {
        val[utility::conversions::to_string_t(U("preemption_mode"))] = ModelBase::toJson(m_Preemption_mode);
    }
    if(m_Allowed_allocation_nodesIsSet)
    {
        val[utility::conversions::to_string_t(U("allowed_allocation_nodes"))] = ModelBase::toJson(m_Allowed_allocation_nodes);
    }
    if(m_Allowed_accountsIsSet)
    {
        val[utility::conversions::to_string_t(U("allowed_accounts"))] = ModelBase::toJson(m_Allowed_accounts);
    }
    if(m_Allowed_groupsIsSet)
    {
        val[utility::conversions::to_string_t(U("allowed_groups"))] = ModelBase::toJson(m_Allowed_groups);
    }
    if(m_Allowed_qosIsSet)
    {
        val[utility::conversions::to_string_t(U("allowed_qos"))] = ModelBase::toJson(m_Allowed_qos);
    }
    if(m_AlternativeIsSet)
    {
        val[utility::conversions::to_string_t(U("alternative"))] = ModelBase::toJson(m_Alternative);
    }
    if(m_Billing_weightsIsSet)
    {
        val[utility::conversions::to_string_t(U("billing_weights"))] = ModelBase::toJson(m_Billing_weights);
    }
    if(m_Default_memory_per_cpuIsSet)
    {
        val[utility::conversions::to_string_t(U("default_memory_per_cpu"))] = ModelBase::toJson(m_Default_memory_per_cpu);
    }
    if(m_Default_time_limitIsSet)
    {
        val[utility::conversions::to_string_t(U("default_time_limit"))] = ModelBase::toJson(m_Default_time_limit);
    }
    if(m_Denied_accountsIsSet)
    {
        val[utility::conversions::to_string_t(U("denied_accounts"))] = ModelBase::toJson(m_Denied_accounts);
    }
    if(m_Denied_qosIsSet)
    {
        val[utility::conversions::to_string_t(U("denied_qos"))] = ModelBase::toJson(m_Denied_qos);
    }
    if(m_Preemption_grace_timeIsSet)
    {
        val[utility::conversions::to_string_t(U("preemption_grace_time"))] = ModelBase::toJson(m_Preemption_grace_time);
    }
    if(m_Maximum_cpus_per_nodeIsSet)
    {
        val[utility::conversions::to_string_t(U("maximum_cpus_per_node"))] = ModelBase::toJson(m_Maximum_cpus_per_node);
    }
    if(m_Maximum_memory_per_nodeIsSet)
    {
        val[utility::conversions::to_string_t(U("maximum_memory_per_node"))] = ModelBase::toJson(m_Maximum_memory_per_node);
    }
    if(m_Maximum_nodes_per_jobIsSet)
    {
        val[utility::conversions::to_string_t(U("maximum_nodes_per_job"))] = ModelBase::toJson(m_Maximum_nodes_per_job);
    }
    if(m_Max_time_limitIsSet)
    {
        val[utility::conversions::to_string_t(U("max_time_limit"))] = ModelBase::toJson(m_Max_time_limit);
    }
    if(m_Min_nodes_per_jobIsSet)
    {
        val[utility::conversions::to_string_t(U("min_nodes_per_job"))] = ModelBase::toJson(m_Min_nodes_per_job);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_NodesIsSet)
    {
        val[utility::conversions::to_string_t(U("nodes"))] = ModelBase::toJson(m_Nodes);
    }
    if(m_Over_time_limitIsSet)
    {
        val[utility::conversions::to_string_t(U("over_time_limit"))] = ModelBase::toJson(m_Over_time_limit);
    }
    if(m_Priority_job_factorIsSet)
    {
        val[utility::conversions::to_string_t(U("priority_job_factor"))] = ModelBase::toJson(m_Priority_job_factor);
    }
    if(m_Priority_tierIsSet)
    {
        val[utility::conversions::to_string_t(U("priority_tier"))] = ModelBase::toJson(m_Priority_tier);
    }
    if(m_QosIsSet)
    {
        val[utility::conversions::to_string_t(U("qos"))] = ModelBase::toJson(m_Qos);
    }
    if(m_StateIsSet)
    {
        val[utility::conversions::to_string_t(U("state"))] = ModelBase::toJson(m_State);
    }
    if(m_Total_cpusIsSet)
    {
        val[utility::conversions::to_string_t(U("total_cpus"))] = ModelBase::toJson(m_Total_cpus);
    }
    if(m_Total_nodesIsSet)
    {
        val[utility::conversions::to_string_t(U("total_nodes"))] = ModelBase::toJson(m_Total_nodes);
    }
    if(m_TresIsSet)
    {
        val[utility::conversions::to_string_t(U("tres"))] = ModelBase::toJson(m_Tres);
    }
    if(m_Maximum_memory_per_cpuIsSet)
    {
        val[utility::conversions::to_string_t(U("maximum_memory_per_cpu"))] = ModelBase::toJson(m_Maximum_memory_per_cpu);
    }
    if(m_Default_memory_per_nodeIsSet)
    {
        val[utility::conversions::to_string_t(U("default_memory_per_node"))] = ModelBase::toJson(m_Default_memory_per_node);
    }

    return val;
}

bool V0_0_38_partition::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("flags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("flags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setFlags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFlags);
            setFlags(refVal_setFlags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("preemption_mode"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("preemption_mode")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setPreemptionMode;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPreemptionMode);
            setPreemptionMode(refVal_setPreemptionMode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("allowed_allocation_nodes"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("allowed_allocation_nodes")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAllowedAllocationNodes;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllowedAllocationNodes);
            setAllowedAllocationNodes(refVal_setAllowedAllocationNodes);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("allowed_accounts"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("allowed_accounts")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAllowedAccounts;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllowedAccounts);
            setAllowedAccounts(refVal_setAllowedAccounts);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("allowed_groups"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("allowed_groups")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAllowedGroups;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllowedGroups);
            setAllowedGroups(refVal_setAllowedGroups);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("allowed_qos"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("allowed_qos")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAllowedQos;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllowedQos);
            setAllowedQos(refVal_setAllowedQos);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("alternative"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("alternative")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAlternative;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAlternative);
            setAlternative(refVal_setAlternative);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("billing_weights"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("billing_weights")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setBillingWeights;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBillingWeights);
            setBillingWeights(refVal_setBillingWeights);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("default_memory_per_cpu"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("default_memory_per_cpu")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setDefaultMemoryPerCpu;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDefaultMemoryPerCpu);
            setDefaultMemoryPerCpu(refVal_setDefaultMemoryPerCpu);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("default_time_limit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("default_time_limit")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setDefaultTimeLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDefaultTimeLimit);
            setDefaultTimeLimit(refVal_setDefaultTimeLimit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("denied_accounts"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("denied_accounts")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDeniedAccounts;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDeniedAccounts);
            setDeniedAccounts(refVal_setDeniedAccounts);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("denied_qos"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("denied_qos")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDeniedQos;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDeniedQos);
            setDeniedQos(refVal_setDeniedQos);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("preemption_grace_time"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("preemption_grace_time")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setPreemptionGraceTime;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPreemptionGraceTime);
            setPreemptionGraceTime(refVal_setPreemptionGraceTime);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("maximum_cpus_per_node"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("maximum_cpus_per_node")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMaximumCpusPerNode;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaximumCpusPerNode);
            setMaximumCpusPerNode(refVal_setMaximumCpusPerNode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("maximum_memory_per_node"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("maximum_memory_per_node")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setMaximumMemoryPerNode;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaximumMemoryPerNode);
            setMaximumMemoryPerNode(refVal_setMaximumMemoryPerNode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("maximum_nodes_per_job"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("maximum_nodes_per_job")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMaximumNodesPerJob;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaximumNodesPerJob);
            setMaximumNodesPerJob(refVal_setMaximumNodesPerJob);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("max_time_limit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("max_time_limit")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setMaxTimeLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaxTimeLimit);
            setMaxTimeLimit(refVal_setMaxTimeLimit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("min_nodes_per_job"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("min_nodes_per_job")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMinNodesPerJob;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMinNodesPerJob);
            setMinNodesPerJob(refVal_setMinNodesPerJob);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("nodes"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("nodes")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setNodes;
            ok &= ModelBase::fromJson(fieldValue, refVal_setNodes);
            setNodes(refVal_setNodes);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("over_time_limit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("over_time_limit")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setOverTimeLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOverTimeLimit);
            setOverTimeLimit(refVal_setOverTimeLimit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("priority_job_factor"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("priority_job_factor")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setPriorityJobFactor;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPriorityJobFactor);
            setPriorityJobFactor(refVal_setPriorityJobFactor);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("priority_tier"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("priority_tier")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setPriorityTier;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPriorityTier);
            setPriorityTier(refVal_setPriorityTier);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("qos"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("qos")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setQos;
            ok &= ModelBase::fromJson(fieldValue, refVal_setQos);
            setQos(refVal_setQos);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("state"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("state")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setState;
            ok &= ModelBase::fromJson(fieldValue, refVal_setState);
            setState(refVal_setState);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("total_cpus"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("total_cpus")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setTotalCpus;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTotalCpus);
            setTotalCpus(refVal_setTotalCpus);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("total_nodes"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("total_nodes")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setTotalNodes;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTotalNodes);
            setTotalNodes(refVal_setTotalNodes);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("tres"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("tres")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setTres;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTres);
            setTres(refVal_setTres);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("maximum_memory_per_cpu"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("maximum_memory_per_cpu")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setMaximumMemoryPerCpu;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaximumMemoryPerCpu);
            setMaximumMemoryPerCpu(refVal_setMaximumMemoryPerCpu);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("default_memory_per_node"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("default_memory_per_node")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setDefaultMemoryPerNode;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDefaultMemoryPerNode);
            setDefaultMemoryPerNode(refVal_setDefaultMemoryPerNode);
        }
    }
    return ok;
}

void V0_0_38_partition::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_FlagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("flags")), m_Flags));
    }
    if(m_Preemption_modeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("preemption_mode")), m_Preemption_mode));
    }
    if(m_Allowed_allocation_nodesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("allowed_allocation_nodes")), m_Allowed_allocation_nodes));
    }
    if(m_Allowed_accountsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("allowed_accounts")), m_Allowed_accounts));
    }
    if(m_Allowed_groupsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("allowed_groups")), m_Allowed_groups));
    }
    if(m_Allowed_qosIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("allowed_qos")), m_Allowed_qos));
    }
    if(m_AlternativeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("alternative")), m_Alternative));
    }
    if(m_Billing_weightsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("billing_weights")), m_Billing_weights));
    }
    if(m_Default_memory_per_cpuIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("default_memory_per_cpu")), m_Default_memory_per_cpu));
    }
    if(m_Default_time_limitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("default_time_limit")), m_Default_time_limit));
    }
    if(m_Denied_accountsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("denied_accounts")), m_Denied_accounts));
    }
    if(m_Denied_qosIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("denied_qos")), m_Denied_qos));
    }
    if(m_Preemption_grace_timeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("preemption_grace_time")), m_Preemption_grace_time));
    }
    if(m_Maximum_cpus_per_nodeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("maximum_cpus_per_node")), m_Maximum_cpus_per_node));
    }
    if(m_Maximum_memory_per_nodeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("maximum_memory_per_node")), m_Maximum_memory_per_node));
    }
    if(m_Maximum_nodes_per_jobIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("maximum_nodes_per_job")), m_Maximum_nodes_per_job));
    }
    if(m_Max_time_limitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("max_time_limit")), m_Max_time_limit));
    }
    if(m_Min_nodes_per_jobIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("min_nodes_per_job")), m_Min_nodes_per_job));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_NodesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("nodes")), m_Nodes));
    }
    if(m_Over_time_limitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("over_time_limit")), m_Over_time_limit));
    }
    if(m_Priority_job_factorIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("priority_job_factor")), m_Priority_job_factor));
    }
    if(m_Priority_tierIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("priority_tier")), m_Priority_tier));
    }
    if(m_QosIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("qos")), m_Qos));
    }
    if(m_StateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("state")), m_State));
    }
    if(m_Total_cpusIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("total_cpus")), m_Total_cpus));
    }
    if(m_Total_nodesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("total_nodes")), m_Total_nodes));
    }
    if(m_TresIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("tres")), m_Tres));
    }
    if(m_Maximum_memory_per_cpuIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("maximum_memory_per_cpu")), m_Maximum_memory_per_cpu));
    }
    if(m_Default_memory_per_nodeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("default_memory_per_node")), m_Default_memory_per_node));
    }
}

bool V0_0_38_partition::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("flags"))))
    {
        std::vector<utility::string_t> refVal_setFlags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("flags"))), refVal_setFlags );
        setFlags(refVal_setFlags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("preemption_mode"))))
    {
        std::vector<utility::string_t> refVal_setPreemptionMode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("preemption_mode"))), refVal_setPreemptionMode );
        setPreemptionMode(refVal_setPreemptionMode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("allowed_allocation_nodes"))))
    {
        utility::string_t refVal_setAllowedAllocationNodes;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("allowed_allocation_nodes"))), refVal_setAllowedAllocationNodes );
        setAllowedAllocationNodes(refVal_setAllowedAllocationNodes);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("allowed_accounts"))))
    {
        utility::string_t refVal_setAllowedAccounts;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("allowed_accounts"))), refVal_setAllowedAccounts );
        setAllowedAccounts(refVal_setAllowedAccounts);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("allowed_groups"))))
    {
        utility::string_t refVal_setAllowedGroups;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("allowed_groups"))), refVal_setAllowedGroups );
        setAllowedGroups(refVal_setAllowedGroups);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("allowed_qos"))))
    {
        utility::string_t refVal_setAllowedQos;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("allowed_qos"))), refVal_setAllowedQos );
        setAllowedQos(refVal_setAllowedQos);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("alternative"))))
    {
        utility::string_t refVal_setAlternative;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("alternative"))), refVal_setAlternative );
        setAlternative(refVal_setAlternative);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("billing_weights"))))
    {
        utility::string_t refVal_setBillingWeights;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("billing_weights"))), refVal_setBillingWeights );
        setBillingWeights(refVal_setBillingWeights);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("default_memory_per_cpu"))))
    {
        int64_t refVal_setDefaultMemoryPerCpu;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("default_memory_per_cpu"))), refVal_setDefaultMemoryPerCpu );
        setDefaultMemoryPerCpu(refVal_setDefaultMemoryPerCpu);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("default_time_limit"))))
    {
        int64_t refVal_setDefaultTimeLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("default_time_limit"))), refVal_setDefaultTimeLimit );
        setDefaultTimeLimit(refVal_setDefaultTimeLimit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("denied_accounts"))))
    {
        utility::string_t refVal_setDeniedAccounts;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("denied_accounts"))), refVal_setDeniedAccounts );
        setDeniedAccounts(refVal_setDeniedAccounts);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("denied_qos"))))
    {
        utility::string_t refVal_setDeniedQos;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("denied_qos"))), refVal_setDeniedQos );
        setDeniedQos(refVal_setDeniedQos);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("preemption_grace_time"))))
    {
        int64_t refVal_setPreemptionGraceTime;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("preemption_grace_time"))), refVal_setPreemptionGraceTime );
        setPreemptionGraceTime(refVal_setPreemptionGraceTime);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("maximum_cpus_per_node"))))
    {
        int32_t refVal_setMaximumCpusPerNode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("maximum_cpus_per_node"))), refVal_setMaximumCpusPerNode );
        setMaximumCpusPerNode(refVal_setMaximumCpusPerNode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("maximum_memory_per_node"))))
    {
        int64_t refVal_setMaximumMemoryPerNode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("maximum_memory_per_node"))), refVal_setMaximumMemoryPerNode );
        setMaximumMemoryPerNode(refVal_setMaximumMemoryPerNode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("maximum_nodes_per_job"))))
    {
        int32_t refVal_setMaximumNodesPerJob;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("maximum_nodes_per_job"))), refVal_setMaximumNodesPerJob );
        setMaximumNodesPerJob(refVal_setMaximumNodesPerJob);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("max_time_limit"))))
    {
        int64_t refVal_setMaxTimeLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("max_time_limit"))), refVal_setMaxTimeLimit );
        setMaxTimeLimit(refVal_setMaxTimeLimit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("min_nodes_per_job"))))
    {
        int32_t refVal_setMinNodesPerJob;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("min_nodes_per_job"))), refVal_setMinNodesPerJob );
        setMinNodesPerJob(refVal_setMinNodesPerJob);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("nodes"))))
    {
        utility::string_t refVal_setNodes;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("nodes"))), refVal_setNodes );
        setNodes(refVal_setNodes);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("over_time_limit"))))
    {
        int32_t refVal_setOverTimeLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("over_time_limit"))), refVal_setOverTimeLimit );
        setOverTimeLimit(refVal_setOverTimeLimit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("priority_job_factor"))))
    {
        int32_t refVal_setPriorityJobFactor;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("priority_job_factor"))), refVal_setPriorityJobFactor );
        setPriorityJobFactor(refVal_setPriorityJobFactor);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("priority_tier"))))
    {
        int32_t refVal_setPriorityTier;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("priority_tier"))), refVal_setPriorityTier );
        setPriorityTier(refVal_setPriorityTier);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("qos"))))
    {
        utility::string_t refVal_setQos;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("qos"))), refVal_setQos );
        setQos(refVal_setQos);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("state"))))
    {
        utility::string_t refVal_setState;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("state"))), refVal_setState );
        setState(refVal_setState);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("total_cpus"))))
    {
        int32_t refVal_setTotalCpus;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("total_cpus"))), refVal_setTotalCpus );
        setTotalCpus(refVal_setTotalCpus);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("total_nodes"))))
    {
        int32_t refVal_setTotalNodes;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("total_nodes"))), refVal_setTotalNodes );
        setTotalNodes(refVal_setTotalNodes);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("tres"))))
    {
        utility::string_t refVal_setTres;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("tres"))), refVal_setTres );
        setTres(refVal_setTres);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("maximum_memory_per_cpu"))))
    {
        int64_t refVal_setMaximumMemoryPerCpu;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("maximum_memory_per_cpu"))), refVal_setMaximumMemoryPerCpu );
        setMaximumMemoryPerCpu(refVal_setMaximumMemoryPerCpu);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("default_memory_per_node"))))
    {
        int64_t refVal_setDefaultMemoryPerNode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("default_memory_per_node"))), refVal_setDefaultMemoryPerNode );
        setDefaultMemoryPerNode(refVal_setDefaultMemoryPerNode);
    }
    return ok;
}

std::vector<utility::string_t>& V0_0_38_partition::getFlags()
{
    return m_Flags;
}

void V0_0_38_partition::setFlags(const std::vector<utility::string_t>& value)
{
    m_Flags = value;
    m_FlagsIsSet = true;
}

bool V0_0_38_partition::flagsIsSet() const
{
    return m_FlagsIsSet;
}

void V0_0_38_partition::unsetFlags()
{
    m_FlagsIsSet = false;
}
std::vector<utility::string_t>& V0_0_38_partition::getPreemptionMode()
{
    return m_Preemption_mode;
}

void V0_0_38_partition::setPreemptionMode(const std::vector<utility::string_t>& value)
{
    m_Preemption_mode = value;
    m_Preemption_modeIsSet = true;
}

bool V0_0_38_partition::preemptionModeIsSet() const
{
    return m_Preemption_modeIsSet;
}

void V0_0_38_partition::unsetPreemption_mode()
{
    m_Preemption_modeIsSet = false;
}
utility::string_t V0_0_38_partition::getAllowedAllocationNodes() const
{
    return m_Allowed_allocation_nodes;
}

void V0_0_38_partition::setAllowedAllocationNodes(const utility::string_t& value)
{
    m_Allowed_allocation_nodes = value;
    m_Allowed_allocation_nodesIsSet = true;
}

bool V0_0_38_partition::allowedAllocationNodesIsSet() const
{
    return m_Allowed_allocation_nodesIsSet;
}

void V0_0_38_partition::unsetAllowed_allocation_nodes()
{
    m_Allowed_allocation_nodesIsSet = false;
}
utility::string_t V0_0_38_partition::getAllowedAccounts() const
{
    return m_Allowed_accounts;
}

void V0_0_38_partition::setAllowedAccounts(const utility::string_t& value)
{
    m_Allowed_accounts = value;
    m_Allowed_accountsIsSet = true;
}

bool V0_0_38_partition::allowedAccountsIsSet() const
{
    return m_Allowed_accountsIsSet;
}

void V0_0_38_partition::unsetAllowed_accounts()
{
    m_Allowed_accountsIsSet = false;
}
utility::string_t V0_0_38_partition::getAllowedGroups() const
{
    return m_Allowed_groups;
}

void V0_0_38_partition::setAllowedGroups(const utility::string_t& value)
{
    m_Allowed_groups = value;
    m_Allowed_groupsIsSet = true;
}

bool V0_0_38_partition::allowedGroupsIsSet() const
{
    return m_Allowed_groupsIsSet;
}

void V0_0_38_partition::unsetAllowed_groups()
{
    m_Allowed_groupsIsSet = false;
}
utility::string_t V0_0_38_partition::getAllowedQos() const
{
    return m_Allowed_qos;
}

void V0_0_38_partition::setAllowedQos(const utility::string_t& value)
{
    m_Allowed_qos = value;
    m_Allowed_qosIsSet = true;
}

bool V0_0_38_partition::allowedQosIsSet() const
{
    return m_Allowed_qosIsSet;
}

void V0_0_38_partition::unsetAllowed_qos()
{
    m_Allowed_qosIsSet = false;
}
utility::string_t V0_0_38_partition::getAlternative() const
{
    return m_Alternative;
}

void V0_0_38_partition::setAlternative(const utility::string_t& value)
{
    m_Alternative = value;
    m_AlternativeIsSet = true;
}

bool V0_0_38_partition::alternativeIsSet() const
{
    return m_AlternativeIsSet;
}

void V0_0_38_partition::unsetAlternative()
{
    m_AlternativeIsSet = false;
}
utility::string_t V0_0_38_partition::getBillingWeights() const
{
    return m_Billing_weights;
}

void V0_0_38_partition::setBillingWeights(const utility::string_t& value)
{
    m_Billing_weights = value;
    m_Billing_weightsIsSet = true;
}

bool V0_0_38_partition::billingWeightsIsSet() const
{
    return m_Billing_weightsIsSet;
}

void V0_0_38_partition::unsetBilling_weights()
{
    m_Billing_weightsIsSet = false;
}
int64_t V0_0_38_partition::getDefaultMemoryPerCpu() const
{
    return m_Default_memory_per_cpu;
}

void V0_0_38_partition::setDefaultMemoryPerCpu(int64_t value)
{
    m_Default_memory_per_cpu = value;
    m_Default_memory_per_cpuIsSet = true;
}

bool V0_0_38_partition::defaultMemoryPerCpuIsSet() const
{
    return m_Default_memory_per_cpuIsSet;
}

void V0_0_38_partition::unsetDefault_memory_per_cpu()
{
    m_Default_memory_per_cpuIsSet = false;
}
int64_t V0_0_38_partition::getDefaultTimeLimit() const
{
    return m_Default_time_limit;
}

void V0_0_38_partition::setDefaultTimeLimit(int64_t value)
{
    m_Default_time_limit = value;
    m_Default_time_limitIsSet = true;
}

bool V0_0_38_partition::defaultTimeLimitIsSet() const
{
    return m_Default_time_limitIsSet;
}

void V0_0_38_partition::unsetDefault_time_limit()
{
    m_Default_time_limitIsSet = false;
}
utility::string_t V0_0_38_partition::getDeniedAccounts() const
{
    return m_Denied_accounts;
}

void V0_0_38_partition::setDeniedAccounts(const utility::string_t& value)
{
    m_Denied_accounts = value;
    m_Denied_accountsIsSet = true;
}

bool V0_0_38_partition::deniedAccountsIsSet() const
{
    return m_Denied_accountsIsSet;
}

void V0_0_38_partition::unsetDenied_accounts()
{
    m_Denied_accountsIsSet = false;
}
utility::string_t V0_0_38_partition::getDeniedQos() const
{
    return m_Denied_qos;
}

void V0_0_38_partition::setDeniedQos(const utility::string_t& value)
{
    m_Denied_qos = value;
    m_Denied_qosIsSet = true;
}

bool V0_0_38_partition::deniedQosIsSet() const
{
    return m_Denied_qosIsSet;
}

void V0_0_38_partition::unsetDenied_qos()
{
    m_Denied_qosIsSet = false;
}
int64_t V0_0_38_partition::getPreemptionGraceTime() const
{
    return m_Preemption_grace_time;
}

void V0_0_38_partition::setPreemptionGraceTime(int64_t value)
{
    m_Preemption_grace_time = value;
    m_Preemption_grace_timeIsSet = true;
}

bool V0_0_38_partition::preemptionGraceTimeIsSet() const
{
    return m_Preemption_grace_timeIsSet;
}

void V0_0_38_partition::unsetPreemption_grace_time()
{
    m_Preemption_grace_timeIsSet = false;
}
int32_t V0_0_38_partition::getMaximumCpusPerNode() const
{
    return m_Maximum_cpus_per_node;
}

void V0_0_38_partition::setMaximumCpusPerNode(int32_t value)
{
    m_Maximum_cpus_per_node = value;
    m_Maximum_cpus_per_nodeIsSet = true;
}

bool V0_0_38_partition::maximumCpusPerNodeIsSet() const
{
    return m_Maximum_cpus_per_nodeIsSet;
}

void V0_0_38_partition::unsetMaximum_cpus_per_node()
{
    m_Maximum_cpus_per_nodeIsSet = false;
}
int64_t V0_0_38_partition::getMaximumMemoryPerNode() const
{
    return m_Maximum_memory_per_node;
}

void V0_0_38_partition::setMaximumMemoryPerNode(int64_t value)
{
    m_Maximum_memory_per_node = value;
    m_Maximum_memory_per_nodeIsSet = true;
}

bool V0_0_38_partition::maximumMemoryPerNodeIsSet() const
{
    return m_Maximum_memory_per_nodeIsSet;
}

void V0_0_38_partition::unsetMaximum_memory_per_node()
{
    m_Maximum_memory_per_nodeIsSet = false;
}
int32_t V0_0_38_partition::getMaximumNodesPerJob() const
{
    return m_Maximum_nodes_per_job;
}

void V0_0_38_partition::setMaximumNodesPerJob(int32_t value)
{
    m_Maximum_nodes_per_job = value;
    m_Maximum_nodes_per_jobIsSet = true;
}

bool V0_0_38_partition::maximumNodesPerJobIsSet() const
{
    return m_Maximum_nodes_per_jobIsSet;
}

void V0_0_38_partition::unsetMaximum_nodes_per_job()
{
    m_Maximum_nodes_per_jobIsSet = false;
}
int64_t V0_0_38_partition::getMaxTimeLimit() const
{
    return m_Max_time_limit;
}

void V0_0_38_partition::setMaxTimeLimit(int64_t value)
{
    m_Max_time_limit = value;
    m_Max_time_limitIsSet = true;
}

bool V0_0_38_partition::maxTimeLimitIsSet() const
{
    return m_Max_time_limitIsSet;
}

void V0_0_38_partition::unsetMax_time_limit()
{
    m_Max_time_limitIsSet = false;
}
int32_t V0_0_38_partition::getMinNodesPerJob() const
{
    return m_Min_nodes_per_job;
}

void V0_0_38_partition::setMinNodesPerJob(int32_t value)
{
    m_Min_nodes_per_job = value;
    m_Min_nodes_per_jobIsSet = true;
}

bool V0_0_38_partition::minNodesPerJobIsSet() const
{
    return m_Min_nodes_per_jobIsSet;
}

void V0_0_38_partition::unsetMin_nodes_per_job()
{
    m_Min_nodes_per_jobIsSet = false;
}
utility::string_t V0_0_38_partition::getName() const
{
    return m_Name;
}

void V0_0_38_partition::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool V0_0_38_partition::nameIsSet() const
{
    return m_NameIsSet;
}

void V0_0_38_partition::unsetName()
{
    m_NameIsSet = false;
}
utility::string_t V0_0_38_partition::getNodes() const
{
    return m_Nodes;
}

void V0_0_38_partition::setNodes(const utility::string_t& value)
{
    m_Nodes = value;
    m_NodesIsSet = true;
}

bool V0_0_38_partition::nodesIsSet() const
{
    return m_NodesIsSet;
}

void V0_0_38_partition::unsetNodes()
{
    m_NodesIsSet = false;
}
int32_t V0_0_38_partition::getOverTimeLimit() const
{
    return m_Over_time_limit;
}

void V0_0_38_partition::setOverTimeLimit(int32_t value)
{
    m_Over_time_limit = value;
    m_Over_time_limitIsSet = true;
}

bool V0_0_38_partition::overTimeLimitIsSet() const
{
    return m_Over_time_limitIsSet;
}

void V0_0_38_partition::unsetOver_time_limit()
{
    m_Over_time_limitIsSet = false;
}
int32_t V0_0_38_partition::getPriorityJobFactor() const
{
    return m_Priority_job_factor;
}

void V0_0_38_partition::setPriorityJobFactor(int32_t value)
{
    m_Priority_job_factor = value;
    m_Priority_job_factorIsSet = true;
}

bool V0_0_38_partition::priorityJobFactorIsSet() const
{
    return m_Priority_job_factorIsSet;
}

void V0_0_38_partition::unsetPriority_job_factor()
{
    m_Priority_job_factorIsSet = false;
}
int32_t V0_0_38_partition::getPriorityTier() const
{
    return m_Priority_tier;
}

void V0_0_38_partition::setPriorityTier(int32_t value)
{
    m_Priority_tier = value;
    m_Priority_tierIsSet = true;
}

bool V0_0_38_partition::priorityTierIsSet() const
{
    return m_Priority_tierIsSet;
}

void V0_0_38_partition::unsetPriority_tier()
{
    m_Priority_tierIsSet = false;
}
utility::string_t V0_0_38_partition::getQos() const
{
    return m_Qos;
}

void V0_0_38_partition::setQos(const utility::string_t& value)
{
    m_Qos = value;
    m_QosIsSet = true;
}

bool V0_0_38_partition::qosIsSet() const
{
    return m_QosIsSet;
}

void V0_0_38_partition::unsetQos()
{
    m_QosIsSet = false;
}
utility::string_t V0_0_38_partition::getState() const
{
    return m_State;
}

void V0_0_38_partition::setState(const utility::string_t& value)
{
    m_State = value;
    m_StateIsSet = true;
}

bool V0_0_38_partition::stateIsSet() const
{
    return m_StateIsSet;
}

void V0_0_38_partition::unsetState()
{
    m_StateIsSet = false;
}
int32_t V0_0_38_partition::getTotalCpus() const
{
    return m_Total_cpus;
}

void V0_0_38_partition::setTotalCpus(int32_t value)
{
    m_Total_cpus = value;
    m_Total_cpusIsSet = true;
}

bool V0_0_38_partition::totalCpusIsSet() const
{
    return m_Total_cpusIsSet;
}

void V0_0_38_partition::unsetTotal_cpus()
{
    m_Total_cpusIsSet = false;
}
int32_t V0_0_38_partition::getTotalNodes() const
{
    return m_Total_nodes;
}

void V0_0_38_partition::setTotalNodes(int32_t value)
{
    m_Total_nodes = value;
    m_Total_nodesIsSet = true;
}

bool V0_0_38_partition::totalNodesIsSet() const
{
    return m_Total_nodesIsSet;
}

void V0_0_38_partition::unsetTotal_nodes()
{
    m_Total_nodesIsSet = false;
}
utility::string_t V0_0_38_partition::getTres() const
{
    return m_Tres;
}

void V0_0_38_partition::setTres(const utility::string_t& value)
{
    m_Tres = value;
    m_TresIsSet = true;
}

bool V0_0_38_partition::tresIsSet() const
{
    return m_TresIsSet;
}

void V0_0_38_partition::unsetTres()
{
    m_TresIsSet = false;
}
int64_t V0_0_38_partition::getMaximumMemoryPerCpu() const
{
    return m_Maximum_memory_per_cpu;
}

void V0_0_38_partition::setMaximumMemoryPerCpu(int64_t value)
{
    m_Maximum_memory_per_cpu = value;
    m_Maximum_memory_per_cpuIsSet = true;
}

bool V0_0_38_partition::maximumMemoryPerCpuIsSet() const
{
    return m_Maximum_memory_per_cpuIsSet;
}

void V0_0_38_partition::unsetMaximum_memory_per_cpu()
{
    m_Maximum_memory_per_cpuIsSet = false;
}
int64_t V0_0_38_partition::getDefaultMemoryPerNode() const
{
    return m_Default_memory_per_node;
}

void V0_0_38_partition::setDefaultMemoryPerNode(int64_t value)
{
    m_Default_memory_per_node = value;
    m_Default_memory_per_nodeIsSet = true;
}

bool V0_0_38_partition::defaultMemoryPerNodeIsSet() const
{
    return m_Default_memory_per_nodeIsSet;
}

void V0_0_38_partition::unsetDefault_memory_per_node()
{
    m_Default_memory_per_nodeIsSet = false;
}
}
}
}
}



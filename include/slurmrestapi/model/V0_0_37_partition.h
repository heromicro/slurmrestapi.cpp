/**
 * Slurm Rest API
 * API to access and control Slurm.
 *
 * The version of the OpenAPI document: 0.0.37
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.6.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * V0_0_37_partition.h
 *
 * 
 */

#ifndef ORG_OPENAPITOOLS_CLIENT_MODEL_V0_0_37_partition_H_
#define ORG_OPENAPITOOLS_CLIENT_MODEL_V0_0_37_partition_H_


#include "slurmrestapi/ModelBase.h"

#include <cpprest/details/basic_types.h>
#include <vector>

namespace org {
namespace openapitools {
namespace client {
namespace model {


/// <summary>
/// 
/// </summary>
class  V0_0_37_partition
    : public ModelBase
{
public:
    V0_0_37_partition();
    virtual ~V0_0_37_partition();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// V0_0_37_partition members

    /// <summary>
    /// partition options
    /// </summary>
    std::vector<utility::string_t>& getFlags();
    bool flagsIsSet() const;
    void unsetFlags();

    void setFlags(const std::vector<utility::string_t>& value);

    /// <summary>
    /// preemption type
    /// </summary>
    std::vector<utility::string_t>& getPreemptionMode();
    bool preemptionModeIsSet() const;
    void unsetPreemption_mode();

    void setPreemptionMode(const std::vector<utility::string_t>& value);

    /// <summary>
    /// list names of allowed allocating nodes
    /// </summary>
    utility::string_t getAllowedAllocationNodes() const;
    bool allowedAllocationNodesIsSet() const;
    void unsetAllowed_allocation_nodes();

    void setAllowedAllocationNodes(const utility::string_t& value);

    /// <summary>
    /// comma delimited list of accounts
    /// </summary>
    utility::string_t getAllowedAccounts() const;
    bool allowedAccountsIsSet() const;
    void unsetAllowed_accounts();

    void setAllowedAccounts(const utility::string_t& value);

    /// <summary>
    /// comma delimited list of groups
    /// </summary>
    utility::string_t getAllowedGroups() const;
    bool allowedGroupsIsSet() const;
    void unsetAllowed_groups();

    void setAllowedGroups(const utility::string_t& value);

    /// <summary>
    /// comma delimited list of qos
    /// </summary>
    utility::string_t getAllowedQos() const;
    bool allowedQosIsSet() const;
    void unsetAllowed_qos();

    void setAllowedQos(const utility::string_t& value);

    /// <summary>
    /// name of alternate partition
    /// </summary>
    utility::string_t getAlternative() const;
    bool alternativeIsSet() const;
    void unsetAlternative();

    void setAlternative(const utility::string_t& value);

    /// <summary>
    /// TRES billing weights
    /// </summary>
    utility::string_t getBillingWeights() const;
    bool billingWeightsIsSet() const;
    void unsetBilling_weights();

    void setBillingWeights(const utility::string_t& value);

    /// <summary>
    /// default MB memory per allocated CPU
    /// </summary>
    int64_t getDefaultMemoryPerCpu() const;
    bool defaultMemoryPerCpuIsSet() const;
    void unsetDefault_memory_per_cpu();

    void setDefaultMemoryPerCpu(int64_t value);

    /// <summary>
    /// default time limit (minutes)
    /// </summary>
    int64_t getDefaultTimeLimit() const;
    bool defaultTimeLimitIsSet() const;
    void unsetDefault_time_limit();

    void setDefaultTimeLimit(int64_t value);

    /// <summary>
    /// comma delimited list of denied accounts
    /// </summary>
    utility::string_t getDeniedAccounts() const;
    bool deniedAccountsIsSet() const;
    void unsetDenied_accounts();

    void setDeniedAccounts(const utility::string_t& value);

    /// <summary>
    /// comma delimited list of denied qos
    /// </summary>
    utility::string_t getDeniedQos() const;
    bool deniedQosIsSet() const;
    void unsetDenied_qos();

    void setDeniedQos(const utility::string_t& value);

    /// <summary>
    /// preemption grace time (seconds)
    /// </summary>
    int64_t getPreemptionGraceTime() const;
    bool preemptionGraceTimeIsSet() const;
    void unsetPreemption_grace_time();

    void setPreemptionGraceTime(int64_t value);

    /// <summary>
    /// maximum allocated CPUs per node
    /// </summary>
    int32_t getMaximumCpusPerNode() const;
    bool maximumCpusPerNodeIsSet() const;
    void unsetMaximum_cpus_per_node();

    void setMaximumCpusPerNode(int32_t value);

    /// <summary>
    /// maximum memory per allocated CPU (MiB)
    /// </summary>
    int64_t getMaximumMemoryPerNode() const;
    bool maximumMemoryPerNodeIsSet() const;
    void unsetMaximum_memory_per_node();

    void setMaximumMemoryPerNode(int64_t value);

    /// <summary>
    /// Max nodes per job
    /// </summary>
    int32_t getMaximumNodesPerJob() const;
    bool maximumNodesPerJobIsSet() const;
    void unsetMaximum_nodes_per_job();

    void setMaximumNodesPerJob(int32_t value);

    /// <summary>
    /// Max time limit per job
    /// </summary>
    int64_t getMaxTimeLimit() const;
    bool maxTimeLimitIsSet() const;
    void unsetMax_time_limit();

    void setMaxTimeLimit(int64_t value);

    /// <summary>
    /// Min number of nodes per job
    /// </summary>
    int32_t getMinNodesPerJob() const;
    bool minNodesPerJobIsSet() const;
    void unsetMin_nodes_per_job();

    void setMinNodesPerJob(int32_t value);

    /// <summary>
    /// Partition name
    /// </summary>
    utility::string_t getName() const;
    bool nameIsSet() const;
    void unsetName();

    void setName(const utility::string_t& value);

    /// <summary>
    /// list names of nodes in partition
    /// </summary>
    utility::string_t getNodes() const;
    bool nodesIsSet() const;
    void unsetNodes();

    void setNodes(const utility::string_t& value);

    /// <summary>
    /// job&#39;s time limit can be exceeded by this number of minutes before cancellation
    /// </summary>
    int32_t getOverTimeLimit() const;
    bool overTimeLimitIsSet() const;
    void unsetOver_time_limit();

    void setOverTimeLimit(int32_t value);

    /// <summary>
    /// job priority weight factor
    /// </summary>
    int32_t getPriorityJobFactor() const;
    bool priorityJobFactorIsSet() const;
    void unsetPriority_job_factor();

    void setPriorityJobFactor(int32_t value);

    /// <summary>
    /// tier for scheduling and preemption
    /// </summary>
    int32_t getPriorityTier() const;
    bool priorityTierIsSet() const;
    void unsetPriority_tier();

    void setPriorityTier(int32_t value);

    /// <summary>
    /// partition QOS name
    /// </summary>
    utility::string_t getQos() const;
    bool qosIsSet() const;
    void unsetQos();

    void setQos(const utility::string_t& value);

    /// <summary>
    /// Partition state
    /// </summary>
    utility::string_t getState() const;
    bool stateIsSet() const;
    void unsetState();

    void setState(const utility::string_t& value);

    /// <summary>
    /// Total cpus in partition
    /// </summary>
    int32_t getTotalCpus() const;
    bool totalCpusIsSet() const;
    void unsetTotal_cpus();

    void setTotalCpus(int32_t value);

    /// <summary>
    /// Total number of nodes in partition
    /// </summary>
    int32_t getTotalNodes() const;
    bool totalNodesIsSet() const;
    void unsetTotal_nodes();

    void setTotalNodes(int32_t value);

    /// <summary>
    /// configured TRES in partition
    /// </summary>
    utility::string_t getTres() const;
    bool tresIsSet() const;
    void unsetTres();

    void setTres(const utility::string_t& value);


protected:
    std::vector<utility::string_t> m_Flags;
    bool m_FlagsIsSet;
    std::vector<utility::string_t> m_Preemption_mode;
    bool m_Preemption_modeIsSet;
    utility::string_t m_Allowed_allocation_nodes;
    bool m_Allowed_allocation_nodesIsSet;
    utility::string_t m_Allowed_accounts;
    bool m_Allowed_accountsIsSet;
    utility::string_t m_Allowed_groups;
    bool m_Allowed_groupsIsSet;
    utility::string_t m_Allowed_qos;
    bool m_Allowed_qosIsSet;
    utility::string_t m_Alternative;
    bool m_AlternativeIsSet;
    utility::string_t m_Billing_weights;
    bool m_Billing_weightsIsSet;
    int64_t m_Default_memory_per_cpu;
    bool m_Default_memory_per_cpuIsSet;
    int64_t m_Default_time_limit;
    bool m_Default_time_limitIsSet;
    utility::string_t m_Denied_accounts;
    bool m_Denied_accountsIsSet;
    utility::string_t m_Denied_qos;
    bool m_Denied_qosIsSet;
    int64_t m_Preemption_grace_time;
    bool m_Preemption_grace_timeIsSet;
    int32_t m_Maximum_cpus_per_node;
    bool m_Maximum_cpus_per_nodeIsSet;
    int64_t m_Maximum_memory_per_node;
    bool m_Maximum_memory_per_nodeIsSet;
    int32_t m_Maximum_nodes_per_job;
    bool m_Maximum_nodes_per_jobIsSet;
    int64_t m_Max_time_limit;
    bool m_Max_time_limitIsSet;
    int32_t m_Min_nodes_per_job;
    bool m_Min_nodes_per_jobIsSet;
    utility::string_t m_Name;
    bool m_NameIsSet;
    utility::string_t m_Nodes;
    bool m_NodesIsSet;
    int32_t m_Over_time_limit;
    bool m_Over_time_limitIsSet;
    int32_t m_Priority_job_factor;
    bool m_Priority_job_factorIsSet;
    int32_t m_Priority_tier;
    bool m_Priority_tierIsSet;
    utility::string_t m_Qos;
    bool m_QosIsSet;
    utility::string_t m_State;
    bool m_StateIsSet;
    int32_t m_Total_cpus;
    bool m_Total_cpusIsSet;
    int32_t m_Total_nodes;
    bool m_Total_nodesIsSet;
    utility::string_t m_Tres;
    bool m_TresIsSet;
};


}
}
}
}

#endif /* ORG_OPENAPITOOLS_CLIENT_MODEL_V0_0_37_partition_H_ */

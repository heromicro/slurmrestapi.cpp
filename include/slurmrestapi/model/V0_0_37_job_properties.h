/**
 * Slurm Rest API
 * API to access and control Slurm.
 *
 * The version of the OpenAPI document: 0.0.37
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.6.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * V0_0_37_job_properties.h
 *
 * 
 */

#ifndef ORG_OPENAPITOOLS_CLIENT_MODEL_V0_0_37_job_properties_H_
#define ORG_OPENAPITOOLS_CLIENT_MODEL_V0_0_37_job_properties_H_


#include "slurmrestapi/ModelBase.h"

#include <cpprest/details/basic_types.h>
#include <vector>
#include "slurmrestapi/Object.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {


/// <summary>
/// 
/// </summary>
class  V0_0_37_job_properties
    : public ModelBase
{
public:
    V0_0_37_job_properties();
    virtual ~V0_0_37_job_properties();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// V0_0_37_job_properties members

    /// <summary>
    /// Charge resources used by this job to specified account.
    /// </summary>
    utility::string_t getAccount() const;
    bool accountIsSet() const;
    void unsetAccount();

    void setAccount(const utility::string_t& value);

    /// <summary>
    /// Define the job accounting and profiling sampling intervals.
    /// </summary>
    utility::string_t getAccountGatherFrequency() const;
    bool accountGatherFrequencyIsSet() const;
    void unsetAccount_gather_frequency();

    void setAccountGatherFrequency(const utility::string_t& value);

    /// <summary>
    /// Arguments to the script.
    /// </summary>
    std::vector<utility::string_t>& getArgv();
    bool argvIsSet() const;
    void unsetArgv();

    void setArgv(const std::vector<utility::string_t>& value);

    /// <summary>
    /// Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
    /// </summary>
    utility::string_t getArray() const;
    bool arrayIsSet() const;
    void unsetarray();

    void setArray(const utility::string_t& value);

    /// <summary>
    /// features required for batch script&#39;s node
    /// </summary>
    utility::string_t getBatchFeatures() const;
    bool batchFeaturesIsSet() const;
    void unsetBatch_features();

    void setBatchFeatures(const utility::string_t& value);

    /// <summary>
    /// Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
    /// </summary>
    int64_t getBeginTime() const;
    bool beginTimeIsSet() const;
    void unsetBegin_time();

    void setBeginTime(int64_t value);

    /// <summary>
    /// Burst buffer specification.
    /// </summary>
    utility::string_t getBurstBuffer() const;
    bool burstBufferIsSet() const;
    void unsetBurst_buffer();

    void setBurstBuffer(const utility::string_t& value);

    /// <summary>
    /// Specifies features that a federated cluster must have to have a sibling job submitted to it.
    /// </summary>
    utility::string_t getClusterConstraint() const;
    bool clusterConstraintIsSet() const;
    void unsetCluster_constraint();

    void setClusterConstraint(const utility::string_t& value);

    /// <summary>
    /// An arbitrary comment.
    /// </summary>
    utility::string_t getComment() const;
    bool commentIsSet() const;
    void unsetComment();

    void setComment(const utility::string_t& value);

    /// <summary>
    /// node features required by job.
    /// </summary>
    utility::string_t getConstraints() const;
    bool constraintsIsSet() const;
    void unsetConstraints();

    void setConstraints(const utility::string_t& value);

    /// <summary>
    /// Count of specialized threads per node reserved by the job for system operations and not used by the application.
    /// </summary>
    int32_t getCoreSpecification() const;
    bool coreSpecificationIsSet() const;
    void unsetCore_specification();

    void setCoreSpecification(int32_t value);

    /// <summary>
    /// Restrict node selection to nodes with at least the specified number of cores per socket.
    /// </summary>
    int32_t getCoresPerSocket() const;
    bool coresPerSocketIsSet() const;
    void unsetCores_per_socket();

    void setCoresPerSocket(int32_t value);

    /// <summary>
    /// Cpu binding
    /// </summary>
    utility::string_t getCpuBinding() const;
    bool cpuBindingIsSet() const;
    void unsetCpu_binding();

    void setCpuBinding(const utility::string_t& value);

    /// <summary>
    /// Cpu binding hint
    /// </summary>
    utility::string_t getCpuBindingHint() const;
    bool cpuBindingHintIsSet() const;
    void unsetCpu_binding_hint();

    void setCpuBindingHint(const utility::string_t& value);

    /// <summary>
    /// Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
    /// </summary>
    utility::string_t getCpuFrequency() const;
    bool cpuFrequencyIsSet() const;
    void unsetCpu_frequency();

    void setCpuFrequency(const utility::string_t& value);

    /// <summary>
    /// Number of CPUs requested per allocated GPU.
    /// </summary>
    utility::string_t getCpusPerGpu() const;
    bool cpusPerGpuIsSet() const;
    void unsetCpus_per_gpu();

    void setCpusPerGpu(const utility::string_t& value);

    /// <summary>
    /// Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
    /// </summary>
    int32_t getCpusPerTask() const;
    bool cpusPerTaskIsSet() const;
    void unsetCpus_per_task();

    void setCpusPerTask(int32_t value);

    /// <summary>
    /// Instruct Slurm to connect the batch script&#39;s standard output directly to the file name.
    /// </summary>
    utility::string_t getCurrentWorkingDirectory() const;
    bool currentWorkingDirectoryIsSet() const;
    void unsetCurrent_working_directory();

    void setCurrentWorkingDirectory(const utility::string_t& value);

    /// <summary>
    /// Remove the job if no ending is possible before this deadline (start &gt; (deadline - time[-min])).
    /// </summary>
    utility::string_t getDeadline() const;
    bool deadlineIsSet() const;
    void unsetDeadline();

    void setDeadline(const utility::string_t& value);

    /// <summary>
    /// Do not reboot nodes in order to satisfied this job&#39;s feature specification if the job has been eligible to run for less than this time period.
    /// </summary>
    int32_t getDelayBoot() const;
    bool delayBootIsSet() const;
    void unsetDelay_boot();

    void setDelayBoot(int32_t value);

    /// <summary>
    /// Defer the start of this job until the specified dependencies have been satisfied completed.
    /// </summary>
    utility::string_t getDependency() const;
    bool dependencyIsSet() const;
    void unsetDependency();

    void setDependency(const utility::string_t& value);

    /// <summary>
    /// Specify alternate distribution methods for remote processes.
    /// </summary>
    utility::string_t getDistribution() const;
    bool distributionIsSet() const;
    void unsetDistribution();

    void setDistribution(const utility::string_t& value);

    /// <summary>
    /// Dictionary of environment entries.
    /// </summary>
    std::shared_ptr<Object> getEnvironment() const;
    bool environmentIsSet() const;
    void unsetEnvironment();

    void setEnvironment(const std::shared_ptr<Object>& value);

    /// <summary>
    /// The job allocation can share nodes just other users with the \&quot;user\&quot; option or with the \&quot;mcs\&quot; option).
    /// </summary>
    utility::string_t getExclusive() const;
    bool exclusiveIsSet() const;
    void unsetExclusive();

    void setExclusive(const utility::string_t& value);

    /// <summary>
    /// Load new login environment for user on job node.
    /// </summary>
    bool isGetUserEnvironment() const;
    bool getUserEnvironmentIsSet() const;
    void unsetGet_user_environment();

    void setGetUserEnvironment(bool value);

    /// <summary>
    /// Specifies a comma delimited list of generic consumable resources.
    /// </summary>
    utility::string_t getGres() const;
    bool gresIsSet() const;
    void unsetGres();

    void setGres(const utility::string_t& value);

    /// <summary>
    /// Specify generic resource task binding options.
    /// </summary>
    utility::string_t getGresFlags() const;
    bool gresFlagsIsSet() const;
    void unsetGres_flags();

    void setGresFlags(const utility::string_t& value);

    /// <summary>
    /// Requested binding of tasks to GPU.
    /// </summary>
    utility::string_t getGpuBinding() const;
    bool gpuBindingIsSet() const;
    void unsetGpu_binding();

    void setGpuBinding(const utility::string_t& value);

    /// <summary>
    /// Requested GPU frequency.
    /// </summary>
    utility::string_t getGpuFrequency() const;
    bool gpuFrequencyIsSet() const;
    void unsetGpu_frequency();

    void setGpuFrequency(const utility::string_t& value);

    /// <summary>
    /// GPUs per job.
    /// </summary>
    utility::string_t getGpus() const;
    bool gpusIsSet() const;
    void unsetGpus();

    void setGpus(const utility::string_t& value);

    /// <summary>
    /// GPUs per node.
    /// </summary>
    utility::string_t getGpusPerNode() const;
    bool gpusPerNodeIsSet() const;
    void unsetGpus_per_node();

    void setGpusPerNode(const utility::string_t& value);

    /// <summary>
    /// GPUs per socket.
    /// </summary>
    utility::string_t getGpusPerSocket() const;
    bool gpusPerSocketIsSet() const;
    void unsetGpus_per_socket();

    void setGpusPerSocket(const utility::string_t& value);

    /// <summary>
    /// GPUs per task.
    /// </summary>
    utility::string_t getGpusPerTask() const;
    bool gpusPerTaskIsSet() const;
    void unsetGpus_per_task();

    void setGpusPerTask(const utility::string_t& value);

    /// <summary>
    /// Specify the job is to be submitted in a held state (priority of zero).
    /// </summary>
    bool isHold() const;
    bool holdIsSet() const;
    void unsetHold();

    void setHold(bool value);

    /// <summary>
    /// If a job has an invalid dependency, then Slurm is to terminate it.
    /// </summary>
    bool isKillOnInvalidDependency() const;
    bool killOnInvalidDependencyIsSet() const;
    void unsetKill_on_invalid_dependency();

    void setKillOnInvalidDependency(bool value);

    /// <summary>
    /// Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
    /// </summary>
    utility::string_t getLicenses() const;
    bool licensesIsSet() const;
    void unsetLicenses();

    void setLicenses(const utility::string_t& value);

    /// <summary>
    /// Notify user by email when certain event types occur.
    /// </summary>
    utility::string_t getMailType() const;
    bool mailTypeIsSet() const;
    void unsetMail_type();

    void setMailType(const utility::string_t& value);

    /// <summary>
    /// User to receive email notification of state changes as defined by mail_type.
    /// </summary>
    utility::string_t getMailUser() const;
    bool mailUserIsSet() const;
    void unsetMail_user();

    void setMailUser(const utility::string_t& value);

    /// <summary>
    /// This parameter is a group among the groups of the user.
    /// </summary>
    utility::string_t getMcsLabel() const;
    bool mcsLabelIsSet() const;
    void unsetMcs_label();

    void setMcsLabel(const utility::string_t& value);

    /// <summary>
    /// Bind tasks to memory.
    /// </summary>
    utility::string_t getMemoryBinding() const;
    bool memoryBindingIsSet() const;
    void unsetMemory_binding();

    void setMemoryBinding(const utility::string_t& value);

    /// <summary>
    /// Minimum real memory per cpu (MB).
    /// </summary>
    int32_t getMemoryPerCpu() const;
    bool memoryPerCpuIsSet() const;
    void unsetMemory_per_cpu();

    void setMemoryPerCpu(int32_t value);

    /// <summary>
    /// Minimum memory required per allocated GPU.
    /// </summary>
    int32_t getMemoryPerGpu() const;
    bool memoryPerGpuIsSet() const;
    void unsetMemory_per_gpu();

    void setMemoryPerGpu(int32_t value);

    /// <summary>
    /// Minimum real memory per node (MB).
    /// </summary>
    int32_t getMemoryPerNode() const;
    bool memoryPerNodeIsSet() const;
    void unsetMemory_per_node();

    void setMemoryPerNode(int32_t value);

    /// <summary>
    /// Minimum number of CPUs per node.
    /// </summary>
    int32_t getMinimumCpusPerNode() const;
    bool minimumCpusPerNodeIsSet() const;
    void unsetMinimum_cpus_per_node();

    void setMinimumCpusPerNode(int32_t value);

    /// <summary>
    /// If a range of node counts is given, prefer the smaller count.
    /// </summary>
    bool isMinimumNodes() const;
    bool minimumNodesIsSet() const;
    void unsetMinimum_nodes();

    void setMinimumNodes(bool value);

    /// <summary>
    /// Specify a name for the job allocation.
    /// </summary>
    utility::string_t getName() const;
    bool nameIsSet() const;
    void unsetName();

    void setName(const utility::string_t& value);

    /// <summary>
    /// Run the job with an adjusted scheduling priority within Slurm.
    /// </summary>
    utility::string_t getNice() const;
    bool niceIsSet() const;
    void unsetNice();

    void setNice(const utility::string_t& value);

    /// <summary>
    /// Do not automatically terminate a job if one of the nodes it has been allocated fails.
    /// </summary>
    bool isNoKill() const;
    bool noKillIsSet() const;
    void unsetNo_kill();

    void setNoKill(bool value);

    /// <summary>
    /// Request that a minimum of minnodes nodes and a maximum node count.
    /// </summary>
    std::vector<int32_t>& getNodes();
    bool nodesIsSet() const;
    void unsetNodes();

    void setNodes(std::vector<int32_t> value);

    /// <summary>
    /// Open the output and error files using append or truncate mode as specified.
    /// </summary>
    utility::string_t getOpenMode() const;
    bool openModeIsSet() const;
    void unsetOpen_mode();

    void setOpenMode(const utility::string_t& value);

    /// <summary>
    /// Request a specific partition for the resource allocation.
    /// </summary>
    utility::string_t getPartition() const;
    bool partitionIsSet() const;
    void unsetPartition();

    void setPartition(const utility::string_t& value);

    /// <summary>
    /// Request a specific job priority.
    /// </summary>
    utility::string_t getPriority() const;
    bool priorityIsSet() const;
    void unsetPriority();

    void setPriority(const utility::string_t& value);

    /// <summary>
    /// Request a quality of service for the job.
    /// </summary>
    utility::string_t getQos() const;
    bool qosIsSet() const;
    void unsetQos();

    void setQos(const utility::string_t& value);

    /// <summary>
    /// Specifies that the batch job should eligible to being requeue.
    /// </summary>
    bool isRequeue() const;
    bool requeueIsSet() const;
    void unsetRequeue();

    void setRequeue(bool value);

    /// <summary>
    /// Allocate resources for the job from the named reservation.
    /// </summary>
    utility::string_t getReservation() const;
    bool reservationIsSet() const;
    void unsetReservation();

    void setReservation(const utility::string_t& value);

    /// <summary>
    /// When a job is within sig_time seconds of its end time, send it the signal sig_num.
    /// </summary>
    utility::string_t getSignal() const;
    bool signalIsSet() const;
    void unsetSignal();

    void setSignal(const utility::string_t& value);

    /// <summary>
    /// Restrict node selection to nodes with at least the specified number of sockets.
    /// </summary>
    int32_t getSocketsPerNode() const;
    bool socketsPerNodeIsSet() const;
    void unsetSockets_per_node();

    void setSocketsPerNode(int32_t value);

    /// <summary>
    /// Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
    /// </summary>
    bool isSpreadJob() const;
    bool spreadJobIsSet() const;
    void unsetSpread_job();

    void setSpreadJob(bool value);

    /// <summary>
    /// Instruct Slurm to connect the batch script&#39;s standard error directly to the file name.
    /// </summary>
    utility::string_t getStandardError() const;
    bool standardErrorIsSet() const;
    void unsetStandard_error();

    void setStandardError(const utility::string_t& value);

    /// <summary>
    /// Instruct Slurm to connect the batch script&#39;s standard input directly to the file name specified.
    /// </summary>
    utility::string_t getStandardInput() const;
    bool standardInputIsSet() const;
    void unsetStandard_input();

    void setStandardInput(const utility::string_t& value);

    /// <summary>
    /// Instruct Slurm to connect the batch script&#39;s standard output directly to the file name.
    /// </summary>
    utility::string_t getStandardOutput() const;
    bool standardOutputIsSet() const;
    void unsetStandard_output();

    void setStandardOutput(const utility::string_t& value);

    /// <summary>
    /// Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
    /// </summary>
    int32_t getTasks() const;
    bool tasksIsSet() const;
    void unsetTasks();

    void setTasks(int32_t value);

    /// <summary>
    /// Request the maximum ntasks be invoked on each core.
    /// </summary>
    int32_t getTasksPerCore() const;
    bool tasksPerCoreIsSet() const;
    void unsetTasks_per_core();

    void setTasksPerCore(int32_t value);

    /// <summary>
    /// Request the maximum ntasks be invoked on each node.
    /// </summary>
    int32_t getTasksPerNode() const;
    bool tasksPerNodeIsSet() const;
    void unsetTasks_per_node();

    void setTasksPerNode(int32_t value);

    /// <summary>
    /// Request the maximum ntasks be invoked on each socket.
    /// </summary>
    int32_t getTasksPerSocket() const;
    bool tasksPerSocketIsSet() const;
    void unsetTasks_per_socket();

    void setTasksPerSocket(int32_t value);

    /// <summary>
    /// Count of specialized threads per node reserved by the job for system operations and not used by the application.
    /// </summary>
    int32_t getThreadSpecification() const;
    bool threadSpecificationIsSet() const;
    void unsetThread_specification();

    void setThreadSpecification(int32_t value);

    /// <summary>
    /// Restrict node selection to nodes with at least the specified number of threads per core.
    /// </summary>
    int32_t getThreadsPerCore() const;
    bool threadsPerCoreIsSet() const;
    void unsetThreads_per_core();

    void setThreadsPerCore(int32_t value);

    /// <summary>
    /// Step time limit.
    /// </summary>
    int32_t getTimeLimit() const;
    bool timeLimitIsSet() const;
    void unsetTime_limit();

    void setTimeLimit(int32_t value);

    /// <summary>
    /// Minimum run time in minutes.
    /// </summary>
    int32_t getTimeMinimum() const;
    bool timeMinimumIsSet() const;
    void unsetTime_minimum();

    void setTimeMinimum(int32_t value);

    /// <summary>
    /// Do not begin execution until all nodes are ready for use.
    /// </summary>
    bool isWaitAllNodes() const;
    bool waitAllNodesIsSet() const;
    void unsetWait_all_nodes();

    void setWaitAllNodes(bool value);

    /// <summary>
    /// Specify wckey to be used with job.
    /// </summary>
    utility::string_t getWckey() const;
    bool wckeyIsSet() const;
    void unsetWckey();

    void setWckey(const utility::string_t& value);


protected:
    utility::string_t m_Account;
    bool m_AccountIsSet;
    utility::string_t m_Account_gather_frequency;
    bool m_Account_gather_frequencyIsSet;
    std::vector<utility::string_t> m_Argv;
    bool m_ArgvIsSet;
    utility::string_t m_array;
    bool m_arrayIsSet;
    utility::string_t m_Batch_features;
    bool m_Batch_featuresIsSet;
    int64_t m_Begin_time;
    bool m_Begin_timeIsSet;
    utility::string_t m_Burst_buffer;
    bool m_Burst_bufferIsSet;
    utility::string_t m_Cluster_constraint;
    bool m_Cluster_constraintIsSet;
    utility::string_t m_Comment;
    bool m_CommentIsSet;
    utility::string_t m_Constraints;
    bool m_ConstraintsIsSet;
    int32_t m_Core_specification;
    bool m_Core_specificationIsSet;
    int32_t m_Cores_per_socket;
    bool m_Cores_per_socketIsSet;
    utility::string_t m_Cpu_binding;
    bool m_Cpu_bindingIsSet;
    utility::string_t m_Cpu_binding_hint;
    bool m_Cpu_binding_hintIsSet;
    utility::string_t m_Cpu_frequency;
    bool m_Cpu_frequencyIsSet;
    utility::string_t m_Cpus_per_gpu;
    bool m_Cpus_per_gpuIsSet;
    int32_t m_Cpus_per_task;
    bool m_Cpus_per_taskIsSet;
    utility::string_t m_Current_working_directory;
    bool m_Current_working_directoryIsSet;
    utility::string_t m_Deadline;
    bool m_DeadlineIsSet;
    int32_t m_Delay_boot;
    bool m_Delay_bootIsSet;
    utility::string_t m_Dependency;
    bool m_DependencyIsSet;
    utility::string_t m_Distribution;
    bool m_DistributionIsSet;
    std::shared_ptr<Object> m_Environment;
    bool m_EnvironmentIsSet;
    utility::string_t m_Exclusive;
    bool m_ExclusiveIsSet;
    bool m_Get_user_environment;
    bool m_Get_user_environmentIsSet;
    utility::string_t m_Gres;
    bool m_GresIsSet;
    utility::string_t m_Gres_flags;
    bool m_Gres_flagsIsSet;
    utility::string_t m_Gpu_binding;
    bool m_Gpu_bindingIsSet;
    utility::string_t m_Gpu_frequency;
    bool m_Gpu_frequencyIsSet;
    utility::string_t m_Gpus;
    bool m_GpusIsSet;
    utility::string_t m_Gpus_per_node;
    bool m_Gpus_per_nodeIsSet;
    utility::string_t m_Gpus_per_socket;
    bool m_Gpus_per_socketIsSet;
    utility::string_t m_Gpus_per_task;
    bool m_Gpus_per_taskIsSet;
    bool m_Hold;
    bool m_HoldIsSet;
    bool m_Kill_on_invalid_dependency;
    bool m_Kill_on_invalid_dependencyIsSet;
    utility::string_t m_Licenses;
    bool m_LicensesIsSet;
    utility::string_t m_Mail_type;
    bool m_Mail_typeIsSet;
    utility::string_t m_Mail_user;
    bool m_Mail_userIsSet;
    utility::string_t m_Mcs_label;
    bool m_Mcs_labelIsSet;
    utility::string_t m_Memory_binding;
    bool m_Memory_bindingIsSet;
    int32_t m_Memory_per_cpu;
    bool m_Memory_per_cpuIsSet;
    int32_t m_Memory_per_gpu;
    bool m_Memory_per_gpuIsSet;
    int32_t m_Memory_per_node;
    bool m_Memory_per_nodeIsSet;
    int32_t m_Minimum_cpus_per_node;
    bool m_Minimum_cpus_per_nodeIsSet;
    bool m_Minimum_nodes;
    bool m_Minimum_nodesIsSet;
    utility::string_t m_Name;
    bool m_NameIsSet;
    utility::string_t m_Nice;
    bool m_NiceIsSet;
    bool m_No_kill;
    bool m_No_killIsSet;
    std::vector<int32_t> m_Nodes;
    bool m_NodesIsSet;
    utility::string_t m_Open_mode;
    bool m_Open_modeIsSet;
    utility::string_t m_Partition;
    bool m_PartitionIsSet;
    utility::string_t m_Priority;
    bool m_PriorityIsSet;
    utility::string_t m_Qos;
    bool m_QosIsSet;
    bool m_Requeue;
    bool m_RequeueIsSet;
    utility::string_t m_Reservation;
    bool m_ReservationIsSet;
    utility::string_t m_Signal;
    bool m_SignalIsSet;
    int32_t m_Sockets_per_node;
    bool m_Sockets_per_nodeIsSet;
    bool m_Spread_job;
    bool m_Spread_jobIsSet;
    utility::string_t m_Standard_error;
    bool m_Standard_errorIsSet;
    utility::string_t m_Standard_input;
    bool m_Standard_inputIsSet;
    utility::string_t m_Standard_output;
    bool m_Standard_outputIsSet;
    int32_t m_Tasks;
    bool m_TasksIsSet;
    int32_t m_Tasks_per_core;
    bool m_Tasks_per_coreIsSet;
    int32_t m_Tasks_per_node;
    bool m_Tasks_per_nodeIsSet;
    int32_t m_Tasks_per_socket;
    bool m_Tasks_per_socketIsSet;
    int32_t m_Thread_specification;
    bool m_Thread_specificationIsSet;
    int32_t m_Threads_per_core;
    bool m_Threads_per_coreIsSet;
    int32_t m_Time_limit;
    bool m_Time_limitIsSet;
    int32_t m_Time_minimum;
    bool m_Time_minimumIsSet;
    bool m_Wait_all_nodes;
    bool m_Wait_all_nodesIsSet;
    utility::string_t m_Wckey;
    bool m_WckeyIsSet;
};


}
}
}
}

#endif /* ORG_OPENAPITOOLS_CLIENT_MODEL_V0_0_37_job_properties_H_ */
